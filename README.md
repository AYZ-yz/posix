posix多线程编程
===
基础函数概念
---
    1.pthread_equal函数只能用来比较两个线程的ID是否一样，因为比较两个线程的ID大小没有意义。
    
    2.线程可以调用pthread_self来获得自己的线程ID,也可以调用pthread_exit来终止自己。
    
    3.pthread_join将阻塞其调用者直到指定线程终止。当join完成时，程序会检查线程的返回值以确保线程返回值与给定的值一样，如果返回值为NULL，
    则程序的退出值为0（表示成功），如果为1（表示失败）。就算忽略返回语句，pthread_join依旧会返回某个值，不管线程在保存返回值的地方保存了
    什么据数据，这个数据都会被当作返回值。
    
    4.线程很可能是系统中包含执行代码所需硬件状态（寄存器，程序计数器，堆栈指针等）的唯一软件环境。
    
    5.有可能在pthread_create函数返回之前，新线程就已经执行完毕了，两者之间不存在同步关系。
    
    6.初始进程从main函数中返回时，进程终止（进程内所有线程也被终止）。如果希望在初始线程终止时，进程中的其它线程继续执行，则需要在初始线程中
    调用pthread_exit而不是直接从main函数中返回。
    
    7.初始线程运行在默认进程堆栈上，该堆栈可以增长到足够的尺寸，而在某些现实中，普通线程的堆栈是受限的，如果堆栈溢出机会导致程序因为段错误或
    总线错误而失败。
    
    8.可以通过调用pthread_mutex_init来动态初始化一个互斥量，并且需要通过调用pthread_mutex来释放它，不需要释放一个使用PTHREAD_MUTEX_INITIALIZER宏静态初始化的互斥量。
   
线程的本质
 ---
    在linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone()。该系统copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数，这个copy和fork不一样，copy的进程和原先的进程共享了所有的变量，和运行环境。

互斥量
---
    不能拷贝互斥变量，因为使用拷贝的互斥变量是不确定的，可以拷贝指向互斥变量的指针，这就就可以使多个函数或线程共享互斥量来实现同步。
