posix多线程编程
===
基础函数概念
---
    1.pthread_equal函数只能用来比较两个线程的ID是否一样，因为比较两个线程的ID大小没有意义。
    
    2.线程可以调用pthread_self来获得自己的线程ID,也可以调用pthread_exit来终止自己。
    
    3.pthread_join将阻塞其调用者直到指定线程终止。当join完成时，程序会检查线程的返回值以确保线程返回值与给定的值一样，如果返回值为NULL，
    则程序的退出值为0（表示成功），如果为1（表示失败）。就算忽略返回语句，pthread_join依旧会返回某个值，不管线程在保存返回值的地方保存了
    什么据数据，这个数据都会被当作返回值。
    
    4.线程很可能是系统中包含执行代码所需硬件状态（寄存器，程序计数器，堆栈指针等）的唯一软件环境。
    
    5.有可能在pthread_create函数返回之前，新线程就已经执行完毕了，两者之间不存在同步关系。
    
    6.初始进程从main函数中返回时，进程终止（进程内所有线程也被终止）。如果希望在初始线程终止时，进程中的其它线程继续执行，则需要在初始线程中
    调用pthread_exit而不是直接从main函数中返回。
    
    7.初始线程运行在默认进程堆栈上，该堆栈可以增长到足够的尺寸，而在某些现实中，普通线程的堆栈是受限的，如果堆栈溢出机会导致程序因为段错误或
    总线错误而失败。
    
    8.可以通过调用pthread_mutex_init来动态初始化一个互斥量，并且需要通过调用pthread_mutex来释放它，不需要释放一个使用PTHREAD_MUTEX_INITIALIZER宏静态初始化的互斥量。
    
    9.多线程的使用场景：计算密集型应用，为了能在多处理器系统上运行，将这些计算分解到多个线程中实现 2/IO密集型应用，为提高性能，将IO操作重叠，很多线程可以同时等待不同的IO操作。
   
线程的本质
 ---
    在linux中，新建的线程并不是在原先的进程中，而是系统通过一个系统调用clone()。该系统copy了一个和原先进程完全一样的进程，并在这个进程中执行线程函数，这个copy和fork不一样，copy的进程和原先的进程共享了所有的变量，和运行环境。

互斥量
---
    不能拷贝互斥变量，因为使用拷贝的互斥变量是不确定的，可以拷贝指向互斥变量的指针，这就就可以使多个函数或线程共享互斥量来实现同步。
   
posix线程数据类型
---
pthread_t               线程标识符
pthread_mutex_t         互斥量
pthread_code_t          条件变量
pthread_key_t           线程私有权握访问键
pthread_attr_t          线程属性对象
pthread_mutexattr_t     互斥量属性对象
pthread_condattr_t      条件变量属性对象
pthread_once_t          一次性初始化控制变量

posix线程函数报错
---
当pthead函数发生错误时，函数放回一个错误代码，调用函数strerror获得错误代码的描述，然后将其打印到stderr文件流中。其中pthread_getspecific函数根本不报错，它仅返回线程私有数据pthread_key_k的值，如果值无效或线程未对它赋值，则直接返回NULL。


    
